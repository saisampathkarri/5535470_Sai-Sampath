-----------------------------------WEEK 4------------------------------------------
**EQUAL STACKS
CODE:

#include <stdio.h>

int equalStacks(int h1[], int n1, int h2[], int n2, int h3[], int n3) {
    int sum1 = 0, sum2 = 0, sum3 = 0;
    for (int i = 0; i < n1; i++) sum1 += h1[i];
    for (int i = 0; i < n2; i++) sum2 += h2[i];
    for (int i = 0; i < n3; i++) sum3 += h3[i];

    int i1 = 0, i2 = 0, i3 = 0;
    while (1) {
        if (i1 == n1 || i2 == n2 || i3 == n3) return 0;
        if (sum1 == sum2 && sum2 == sum3) return sum1;
        if (sum1 >= sum2 && sum1 >= sum3) sum1 -= h1[i1++];
        else if (sum2 >= sum1 && sum2 >= sum3) sum2 -= h2[i2++];
        else sum3 -= h3[i3++];
    }
}

int main() {
    int n1, n2, n3;
    scanf("%d %d %d", &n1, &n2, &n3);
    int h1[n1], h2[n2], h3[n3];
    for (int i = 0; i < n1; i++) scanf("%d", &h1[i]);
    for (int i = 0; i < n2; i++) scanf("%d", &h2[i]);
    for (int i = 0; i < n3; i++) scanf("%d", &h3[i]);

    printf("%d\n", equalStacks(h1, n1, h2, n2, h3, n3));
    return 0;
}
-----------------------------------------------------------------------------------
**THE MAXIMUM
CODE:

#include <stdio.h>

void maxSubarray(int arr[], int n) {
    int maxSub = arr[0], current = arr[0];
    int maxSeq = arr[0] > 0 ? arr[0] : arr[0];

    for (int i = 1; i < n; i++) {
        if (arr[i] > 0) {
            if (maxSeq > 0) maxSeq += arr[i];
            else maxSeq = arr[i];
        } else if (maxSeq < 0 && arr[i] > maxSeq) {
            maxSeq = arr[i];
        }

        if (current + arr[i] > arr[i]) current += arr[i];
        else current = arr[i];

        if (current > maxSub) maxSub = current;
    }

    printf("%d %d\n", maxSub, maxSeq);
}

int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        int n;
        scanf("%d", &n);
        int arr[n];
        for (int i = 0; i < n; i++) scanf("%d", &arr[i]);
        maxSubarray(arr, n);
    }
    return 0;
}
-----------------------------------------------------------------------------------
**LEGO BLOCKS
CODE:

#include <stdio.h>
#include <string.h>
#define MOD 1000000007

long long powmod(long long base, long long exp) {
    long long res = 1;
    while (exp > 0) {
        if (exp & 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp >>= 1;
    }
    return res;
}

int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        int n, m;
        scanf("%d %d", &n, &m);

        long long row[m+1], total[m+1], solid[m+1];
        memset(row, 0, sizeof(row));
        memset(total, 0, sizeof(total));
        memset(solid, 0, sizeof(solid));

        row[0] = 1;
        for (int i = 1; i <= m; i++) {
            for (int b = 1; b <= 4; b++) {
                if (i - b >= 0) row[i] = (row[i] + row[i - b]) % MOD;
            }
        }

        for (int i = 1; i <= m; i++) {
            total[i] = powmod(row[i], n);
        }

        for (int i = 1; i <= m; i++) {
            long long invalid = 0;
            for (int j = 1; j < i; j++) {
                invalid = (invalid + solid[j] * total[i - j]) % MOD;
            }
            solid[i] = (total[i] - invalid + MOD) % MOD;
        }

        printf("%lld\n", solid[m]);
    }
    return 0;
}
-----------------------------------------------------------------------------------
**QHEAP1
CODE:

#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int *arr;
    int size;
} MinHeap;

MinHeap* createHeap(int n) {
    MinHeap* heap = malloc(sizeof(MinHeap));
    heap->arr = malloc(sizeof(int) * n);
    heap->size = 0;
    return heap;
}

void swap(int *a, int *b) { int t = *a; *a = *b; *b = t; }

void heapifyUp(MinHeap* h, int i) {
    while (i && h->arr[i] < h->arr[(i-1)/2]) {
        swap(&h->arr[i], &h->arr[(i-1)/2]);
        i = (i-1)/2;
    }
}

void heapifyDown(MinHeap* h, int i) {
    int left, right, smallest;
    while (1) {
        left = 2*i + 1;
        right = 2*i + 2;
        smallest = i;
        if (left < h->size && h->arr[left] < h->arr[smallest]) smallest = left;
        if (right < h->size && h->arr[right] < h->arr[smallest]) smallest = right;
        if (smallest != i) { swap(&h->arr[i], &h->arr[smallest]); i = smallest; }
        else break;
    }
}

void insert(MinHeap* h, int val) {
    h->arr[h->size++] = val;
    heapifyUp(h, h->size-1);
}

int extractMin(MinHeap* h) {
    int min = h->arr[0];
    h->arr[0] = h->arr[--h->size];
    heapifyDown(h, 0);
    return min;
}

int cookies(int k, int A[], int n) {
    MinHeap* heap = createHeap(n);
    for (int i = 0; i < n; i++) insert(heap, A[i]);
    int operations = 0;

    while (heap->size > 0 && heap->arr[0] < k) {
        if (heap->size < 2) return -1;
        int least = extractMin(heap);
        int second = extractMin(heap);
        int newCookie = least + 2*second;
        insert(heap, newCookie);
        operations++;
    }
    return operations;
}

int main() {
    int n, k;
    scanf("%d %d", &n, &k);
    int A[n];
    for (int i = 0; i < n; i++) scanf("%d", &A[i]);
    printf("%d\n", cookies(k, A, n));
    return 0;
}
----------------------------------------------------------------------------------
**JESSY AND COOKIES
CODE:

#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int *arr;
    int size;
} MinHeap;

MinHeap* createHeap(int n) {
    MinHeap* heap = malloc(sizeof(MinHeap));
    heap->arr = malloc(sizeof(int) * n);
    heap->size = 0;
    return heap;
}

void swap(int *a, int *b) { int t = *a; *a = *b; *b = t; }

void heapifyUp(MinHeap* h, int i) {
    while (i && h->arr[i] < h->arr[(i-1)/2]) {
        swap(&h->arr[i], &h->arr[(i-1)/2]);
        i = (i-1)/2;
    }
}

void heapifyDown(MinHeap* h, int i) {
    int left, right, smallest;
    while (1) {
        left = 2*i + 1;
        right = 2*i + 2;
        smallest = i;
        if (left < h->size && h->arr[left] < h->arr[smallest]) smallest = left;
        if (right < h->size && h->arr[right] < h->arr[smallest]) smallest = right;
        if (smallest != i) { swap(&h->arr[i], &h->arr[smallest]); i = smallest; }
        else break;
    }
}

void insert(MinHeap* h, int val) {
    h->arr[h->size++] = val;
    heapifyUp(h, h->size-1);
}

int extractMin(MinHeap* h) {
    int min = h->arr[0];
    h->arr[0] = h->arr[--h->size];
    heapifyDown(h, 0);
    return min;
}

int cookies(int k, int A[], int n) {
    MinHeap* heap = createHeap(n);
    for (int i = 0; i < n; i++) insert(heap, A[i]);
    int operations = 0;

    while (heap->size > 0 && heap->arr[0] < k) {
        if (heap->size < 2) return -1;
        int least = extractMin(heap);
        int second = extractMin(heap);
        int newCookie = least + 2*second;
        insert(heap, newCookie);
        operations++;
    }
    return operations;
}

int main() {
    int n, k;
    scanf("%d %d", &n, &k);
    int A[n];
    for (int i = 0; i < n; i++) scanf("%d", &A[i]);
    printf("%d\n", cookies(k, A, n));
    return 0;
}
------------------------------------------------------------------------------------
**HACKERLAND RADIO TRANSMIITTERS
CODE:

#include <stdio.h>
#include <stdlib.h>

int cmp(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int hackerlandRadioTransmitters(int x[], int n, int k) {
    qsort(x, n, sizeof(int), cmp);
    int count = 0;
    int i = 0;
    
    while (i < n) {
        int loc = x[i] + k;
        while (i < n && x[i] <= loc) i++;
        int transmitter = x[i - 1];
        loc = transmitter + k;
        while (i < n && x[i] <= loc) i++;
        count++;
    }
    
    return count;
}

int main() {
    int n, k;
    scanf("%d %d", &n, &k);
    int x[n];
    for (int i = 0; i < n; i++) scanf("%d", &x[i]);
    printf("%d\n", hackerlandRadioTransmitters(x, n, k));
    return 0;
}
---------------------------------------------------------------------------------
**QUERIES WITH FIXED LENGTH
CODE:

#include <stdio.h>
#include <stdlib.h>

int min(int a, int b) { return a < b ? a : b; }

int min_of_max(int arr[], int n, int k) {
    int *deque = malloc(n * sizeof(int));
    int front = 0, back = -1;
    int minMax = __INT_MAX__;

    for (int i = 0; i < n; i++) {
        while (front <= back && deque[front] <= i - k) front++;
        while (front <= back && arr[deque[back]] <= arr[i]) back--;
        deque[++back] = i;
        if (i >= k - 1) {
            minMax = min(minMax, arr[deque[front]]);
        }
    }

    free(deque);
    return minMax;
}

int main() {
    int n, q;
    scanf("%d %d", &n, &q);
    int arr[n];
    for (int i = 0; i < n; i++) scanf("%d", &arr[i]);

    for (int i = 0; i < q; i++) {
        int k;
        scanf("%d", &k);
        printf("%d\n", min_of_max(arr, n, k));
    }

    return 0;
}
-----------------------------------------------------------------------------------
**ARRAY MANIPULATION
CODE:

#include <stdio.h>
#include <stdlib.h>

long arrayManipulation(int n, int queries_rows, int queries_cols, int queries[queries_rows][queries_cols]) {
    long *arr = calloc(n + 2, sizeof(long));
    for(int i=0;i<queries_rows;i++){
        int a = queries[i][0];
        int b = queries[i][1];
        int k = queries[i][2];
        arr[a] += k;
        arr[b+1] -= k;
    }

    long max = 0, current = 0;
    for(int i=1;i<=n;i++){
        current += arr[i];
        if(current > max) max = current;
    }

    free(arr);
    return max;
}

int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    int queries[m][3];
    for(int i=0;i<m;i++){
        scanf("%d %d %d", &queries[i][0], &queries[i][1], &queries[i][2]);
    }
    printf("%ld\n", arrayManipulation(n, m, 3, queries));
    return 0;
}
------------------------------------------------------------------------------------
**CASTLE ON THE GRID
CODE:

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct {
    int x, y, moves;
} Node;

int minimumMoves(char **grid, int n, int startX, int startY, int goalX, int goalY) {
    bool visited[n][n];
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            visited[i][j]=false;

    Node* queue = malloc(n*n*sizeof(Node));
    int front=0, rear=0;

    queue[rear++] = (Node){startX, startY, 0};
    visited[startX][startY]=true;

    int dx[4]={-1,1,0,0};
    int dy[4]={0,0,-1,1};

    while(front < rear){
        Node curr = queue[front++];
        if(curr.x==goalX && curr.y==goalY) return curr.moves;

        for(int dir=0; dir<4; dir++){
            int nx=curr.x+dx[dir];
            int ny=curr.y+dy[dir];

            while(nx>=0 && nx<n && ny>=0 && ny<n && grid[nx][ny]=='.'){
                if(!visited[nx][ny]){
                    visited[nx][ny]=true;
                    queue[rear++] = (Node){nx, ny, curr.moves+1};
                }
                nx += dx[dir];
                ny += dy[dir];
            }
        }
    }
    free(queue);
    return -1;
}

int main() {
    int n;
    scanf("%d", &n);
    char** grid = malloc(n*sizeof(char*));
    for(int i=0;i<n;i++){
        grid[i]=malloc((n+1)*sizeof(char));
        scanf("%s", grid[i]);
    }
    int startX, startY, goalX, goalY;
    scanf("%d %d %d %d", &startX, &startY, &goalX, &goalY);
    printf("%d\n", minimumMoves(grid, n, startX, startY, goalX, goalY));
    for(int i=0;i<n;i++) free(grid[i]);
    free(grid);
    return 0;
}
------------------------------------------------------------------------------------
**ROADS AND LIBRARIES
CODE:

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct Node {
    int val;
    struct Node* next;
} Node;

void add_edge(Node** graph, int u, int v) {
    Node* node = malloc(sizeof(Node));
    node->val = v;
    node->next = graph[u];
    graph[u] = node;
}

void dfs(int u, Node** graph, bool* visited) {
    visited[u] = true;
    Node* temp = graph[u];
    while(temp) {
        if (!visited[temp->val]) dfs(temp->val, graph, visited);
        temp = temp->next;
    }
}

long long roadsAndLibraries(int n, int c_lib, int c_road, int m, int cities[][2]) {
    if (c_lib <= c_road) return (long long)n * c_lib;

    Node* graph[n + 1];
    for(int i=0; i<=n; i++) graph[i] = NULL;
    for(int i=0; i<m; i++) {
        int u = cities[i][0], v = cities[i][1];
        add_edge(graph, u, v);
        add_edge(graph, v, u);
    }

    bool visited[n+1];
    for(int i=0; i<=n; i++) visited[i] = false;

    long long cost = 0;
    for(int i=1; i<=n; i++) {
        if(!visited[i]) {
            dfs(i, graph, visited);
            cost += c_lib;
        }
    }

    for(int i=1; i<=n; i++) visited[i] = false;
    for(int i=1; i<=n; i++) {
        if(!visited[i]) {
            int stack[n], top=0;
            stack[top++] = i;
            visited[i] = true;
            int count = 1;

            while(top > 0) {
                int u = stack[--top];
                Node* temp = graph[u];
                while(temp) {
                    int v = temp->val;
                    if(!visited[v]) {
                        visited[v] = true;
                        stack[top++] = v;
                        count++;
                    }
                    temp = temp->next;
                }
            }
            cost += (long long)(count - 1) * c_road;
        }
    }

    return cost;
}

int main() {
    int q;
    scanf("%d", &q);
    while(q--) {
        int n, m, c_lib, c_road;
        scanf("%d %d %d %d", &n, &m, &c_lib, &c_road);
        int cities[m][2];
        for(int i=0;i<m;i++) scanf("%d %d", &cities[i][0], &cities[i][1]);
        printf("%lld\n", roadsAndLibraries(n, c_lib, c_road, m, cities));
    }
    return 0;
}
------------------------------------------------------------------------------------






----------------------------------------------------------------------------------




